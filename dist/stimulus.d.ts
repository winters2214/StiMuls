// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   sentinella

import { TokenListObserverDelegate } from "sentinella";
import { AttributeObserverDelegate } from "sentinella";

export class Action {
    static defaultEventNames: {
        [tagName: string]: (element: Element) => string;
    };
    object: object;
    eventTarget: EventTarget;
    delegatedTarget: EventTarget;
    descriptor: Descriptor;
    constructor(object: object, eventTarget: EventTarget, delegatedTarget: EventTarget, descriptor: Descriptor);
    readonly eventName: string;
    readonly methodName: string;
    readonly allowsDefault: boolean;
    readonly method: Function | undefined;
    readonly isDirect: boolean;
    readonly isDelegated: boolean;
    isEqualTo(action?: Action): boolean;
    performWithEvent(event: Event): void;
}

export class Application {
    static start(): Application;
    constructor(router: Router);
    start(): void;
    stop(): void;
    register(identifier: string, controllerConstructor: ControllerConstructor): void;
}

export interface ControllerConstructor {
    new (identifier: string, element: Element, delegate: ControllerDelegate): Controller;
}
export interface ControllerDelegate {
    controllerCanControlElement(controller: Controller, element: Element): boolean;
}
export class Controller implements InlineActionObserverDelegate, TargetSetDelegate {
    identifier: string;
    element: Element;
    delegate: ControllerDelegate;
    targets: TargetSet;
    constructor(identifier: string, element: Element, delegate: ControllerDelegate);
    initialize(): void;
    beforeConnect(): void;
    connect(): void;
    disconnect(): void;
    afterDisconnect(): void;
    readonly parentElement: Element | null;
    addAction(action: Action): void;
    removeAction(action: Action): void;
    getObjectForInlineActionDescriptor(descriptor: Descriptor): object;
    inlineActionConnected(action: Action): void;
    inlineActionDisconnected(action: Action): void;
    canControlElement(element: Element): boolean;
}

export class Descriptor {
    eventName: string | null;
    methodName: string;
    allowsDefault: boolean;
    static parse(descriptorString: string): Descriptor;
    constructor(eventName: string | null, methodName: string, allowsDefault?: boolean);
    toString(): string;
}

export class Router implements TokenListObserverDelegate, ControllerDelegate {
    constructor(element: Element, attributeName: string);
    readonly element: Element;
    start(): void;
    stop(): void;
    register(identifier: string, controllerConstructor: ControllerConstructor): void;
    controllerCanControlElement(controller: Controller, element: Element): boolean;
    elementMatchedTokenForAttribute(element: Element, token: string, attributeName: string): void;
    elementUnmatchedTokenForAttribute(element: Element, token: string, attributeName: string): void;
}

export interface InlineActionObserverDelegate {
    getObjectForInlineActionDescriptor(descriptor: Descriptor): object;
    inlineActionConnected(action: Action): any;
    inlineActionDisconnected(action: Action): any;
    canControlElement(element: Element): any;
}
export class InlineActionObserver implements AttributeObserverDelegate {
    identifier: string;
    constructor(identifier: string, element: Element, delegate: InlineActionObserverDelegate);
    readonly element: Element;
    readonly attributeName: string;
    start(): void;
    stop(): void;
    elementMatchedAttribute(element: Element, attributeName: string): void;
    elementAttributeValueChanged(element: Element, attributeName: string): void;
    elementUnmatchedAttribute(element: Element, attributeName: string): void;
}

export interface TargetSetDelegate {
    canControlElement(element: Element): any;
}
export class TargetSet {
    identifier: string;
    element: Element;
    constructor(identifier: string, element: Element, delegate: TargetSetDelegate);
    has(targetName: string): boolean;
    find(targetName: string): Element | null;
    findAll(targetName: string): Element[];
}

