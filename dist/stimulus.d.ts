// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   sentinella

import { AttributeObserverDelegate } from "sentinella";
import { TokenListObserverDelegate } from "sentinella";

export { decorators };

export function on(eventName: string, actionOptions?: ActionOptions): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;

export type EventTargetMatcher = (eventTarget: EventTarget) => boolean;
export class Action {
    object: Object;
    descriptor: Descriptor;
    eventTarget: EventTarget;
    delegatedTargetMatcher: EventTargetMatcher | null;
    constructor(object: Object, descriptor: Descriptor, eventTarget: EventTarget, delegatedTargetMatcher: EventTargetMatcher);
    readonly eventName: string;
    readonly methodName: string;
    readonly preventsDefault: boolean;
    readonly isDirect: boolean;
    readonly isDelegated: boolean;
    readonly method: Function;
    hasSameDescriptorAs(action: Action | null): boolean;
    matchDelegatedTarget(eventTarget: EventTarget): boolean;
    invokeWithEventAndTarget(event: Event, eventTarget: EventTarget): void;
}

export class Application {
    configuration: Configuration;
    static start(configurationOptions?: ConfigurationOptions): Application;
    constructor(configurationOptions?: ConfigurationOptions);
    start(): void;
    stop(): void;
    register(identifier: string, controllerConstructor: ControllerConstructor): void;
}

export interface ControllerConstructor {
    new (context: Context): Controller;
}
export class Controller {
    context: Context;
    constructor(context: Context);
    readonly application: Application;
    readonly element: Element;
    readonly identifier: string;
    readonly targets: TargetSet;
    readonly data: DataSet;
    initialize(): void;
    connect(): void;
    disconnect(): void;
    addAction(action: Action): any;
    addAction(descriptorString: string, options?: ActionOptions): any;
    addAction(descriptorString: string, eventTarget: EventTarget): any;
    removeAction(action: Action): void;
}

export interface DescriptorOptions {
    identifier?: string;
    targetName?: string;
    eventName?: string;
    methodName?: string;
    preventsDefault?: boolean;
}
export class Descriptor {
    identifier: string;
    targetName: string | null;
    eventName: string;
    methodName: string;
    preventsDefault: boolean;
    static forOptions(options: DescriptorOptions): Descriptor;
    static forElementWithInlineDescriptorString(element: Element, descriptorString: string): Descriptor;
    constructor(identifier: string, targetName: string | null, eventName: string, methodName: string, preventsDefault: boolean);
    isEqualTo(descriptor: Descriptor | null): boolean;
    toString(): string;
}

export class Logger {
    static enable(): void;
    static disable(): void;
    static create(...tags: any[]): Logger;
    constructor(tags?: any[]);
    tag(...tags: any[]): Logger;
    log(...messages: any[]): void;
}

export interface ActionOptions {
    targetName: string;
}
export class Context implements InlineActionObserverDelegate {
    contextSet: ContextSet;
    element: Element;
    controller: Controller;
    targets: TargetSet;
    data: DataSet;
    constructor(contextSet: ContextSet, element: Element);
    connect(): void;
    disconnect(): void;
    canControlElement(element: Element): boolean;
    readonly application: Application;
    readonly identifier: string;
    readonly configuration: Configuration;
    readonly controllerAttribute: string;
    readonly actionAttribute: string;
    readonly targetAttribute: string;
    readonly parentElement: Element | null;
    addAction(action: Action): any;
    addAction(descriptorString: string, options?: ActionOptions): any;
    addAction(descriptorString: string, eventTarget: EventTarget): any;
    removeAction(action: Action): void;
    getObjectForInlineActionDescriptor(descriptor: Descriptor): object;
    inlineActionConnected(action: Action): void;
    inlineActionDisconnected(action: Action): void;
}

export interface Configuration {
    rootElement: Element;
    controllerAttribute: string;
    actionAttribute: string;
    targetAttribute: string;
}
export interface ConfigurationOptions {
    rootElement?: Element;
    controllerAttribute?: string;
    actionAttribute?: string;
    targetAttribute?: string;
}
export const defaultConfiguration: Configuration;
export function createConfiguration(configuration: ConfigurationOptions): Configuration;

export class TargetSet {
    context: Context;
    constructor(context: Context);
    readonly attributeName: string;
    readonly element: Element;
    readonly identifier: string;
    has(targetName: string): boolean;
    find(targetName: string): Element | null;
    findAll(targetName: string): Element[];
    matchesElementWithTargetName(element: Element, targetName: string): boolean;
}

export class DataSet {
    context: Context;
    constructor(context: Context);
    readonly element: Element;
    readonly identifier: string;
    get(key: string): string | null;
    set(key: string, value: any): string | null;
}

export class ContextSet {
    router: Router;
    identifier: string;
    controllerConstructor: ControllerConstructor;
    constructor(router: Router, identifier: string, controllerConstructor: ControllerConstructor);
    readonly application: Application;
    readonly size: number;
    connect(element: Element): void;
    disconnect(element: Element): void;
}

export interface InlineActionObserverDelegate {
    getObjectForInlineActionDescriptor(descriptor: Descriptor): object;
    inlineActionConnected(action: Action): any;
    inlineActionDisconnected(action: Action): any;
}
export class InlineActionObserver implements AttributeObserverDelegate {
    context: Context;
    delegate: InlineActionObserverDelegate;
    constructor(context: Context, delegate: InlineActionObserverDelegate);
    readonly attributeName: string;
    readonly element: Element;
    readonly identifier: string;
    start(): void;
    stop(): void;
    elementMatchedAttribute(element: Element, attributeName: string): void;
    elementAttributeValueChanged(element: Element, attributeName: string): void;
    elementUnmatchedAttribute(element: Element, attributeName: string): void;
}

export class Router implements TokenListObserverDelegate {
    application: Application;
    constructor(application: Application);
    readonly configuration: Configuration;
    readonly element: Element;
    readonly controllerAttribute: string;
    start(): void;
    stop(): void;
    register(identifier: string, controllerConstructor: ControllerConstructor): void;
    elementMatchedTokenForAttribute(element: Element, token: string, attributeName: string): void;
    elementUnmatchedTokenForAttribute(element: Element, token: string, attributeName: string): void;
}

